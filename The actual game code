import pygame, sys, random, math, json, hashlib, os, time, secrets

# =========================================================
# ===================== USER SAFETY =======================
# =========================================================

DATA_FILE = "users.json"
MAX_LOGIN_ATTEMPTS = 5
LOCKOUT_TIME = 30  # seconds
MIN_PASSWORD_LEN = 6
MAX_INPUT_LEN = 32

def load_users():
    if not os.path.exists(DATA_FILE):
        return {}
    try:
        with open(DATA_FILE, "r") as f:
            return json.load(f)
    except Exception:
        return {}

def save_users(users):
    with open(DATA_FILE, "w") as f:
        json.dump(users, f, indent=2)

def hash_password(password, salt):
    return hashlib.sha256((salt + password).encode()).hexdigest()

def valid_input(text):
    return text.isprintable() and len(text) <= MAX_INPUT_LEN

def now():
    return int(time.time())

# =========================================================
# ===================== PYGAME SETUP ======================
# =========================================================

pygame.init()
WIDTH, HEIGHT = 640, 480
screen = pygame.display.set_mode((WIDTH, HEIGHT))
pygame.display.set_caption("Drift in the Dark")
clock = pygame.time.Clock()
font = pygame.font.SysFont(None, 28)

# =========================================================
# ======================= COLORS ==========================
# =========================================================

BG = (15, 15, 25)
TEXT = (220, 220, 240)
PLAYER_COLOR = (200, 200, 255)
STAR_COLOR = (255, 220, 120)
ENEMY_COLOR = (200, 80, 80)
BOSS_COLOR = (140, 60, 160)

# =========================================================
# ======================= CONSTANTS =======================
# =========================================================

PLAYER_SIZE = 40
PLAYER_SPEED = 5
STAR_SIZE = 20
ENEMY_SIZE = 35

MAX_SPEED_TOLERANCE = PLAYER_SPEED * 1.6

# =========================================================
# ======================= HELPERS =========================
# =========================================================

def draw(text, x, y, center=True):
    surf = font.render(text, True, TEXT)
    rect = surf.get_rect()
    rect.center = (x, y) if center else rect.move(x, y)
    screen.blit(surf, rect)

def clamp(vx, vy, m):
    mag = math.hypot(vx, vy)
    if mag == 0:
        return 0, 0
    s = min(1, m / mag)
    return vx * s, vy * s

def generate_boss_dialogue():
    return " ".join([
        random.choice([
            "I remember your hesitation.",
            "You should not have come this far.",
            "Your movement betrays you.",
            "I have learned your rhythm."
        ]),
        random.choice([
            "Patterns decay.",
            "You repeat yourself.",
            "All paths curve inward.",
            "Fear leaves fingerprints."
        ]),
        random.choice([
            "This is where it breaks.",
            "You will slow.",
            "You will remain.",
            "You will be remembered."
        ])
    ])

# =========================================================
# ======================= ENTITIES ========================
# =========================================================

class Enemy:
    def __init__(self, level):
        self.rect = pygame.Rect(
            random.randint(0, WIDTH - ENEMY_SIZE),
            random.randint(0, HEIGHT - ENEMY_SIZE),
            ENEMY_SIZE, ENEMY_SIZE
        )
        self.vx, self.vy = random.uniform(-1,1), random.uniform(-1,1)
        self.memory = pygame.Vector2()
        self.speed = 1.5 + level * 0.15
        self.focus = min(0.05 + level * 0.01, 0.25)

    def update(self, player, delta):
        self.memory = self.memory.lerp(delta, self.focus)
        dx = (player.centerx - self.rect.centerx) + self.memory.x * 20
        dy = (player.centery - self.rect.centery) + self.memory.y * 20
        d = math.hypot(dx, dy)
        if d:
            dx, dy = dx/d, dy/d
        self.vx = self.vx*0.9 + dx*self.focus*2
        self.vy = self.vy*0.9 + dy*self.focus*2
        self.vx, self.vy = clamp(self.vx, self.vy, self.speed)
        self.rect.x += self.vx
        self.rect.y += self.vy
        self.rect.clamp_ip(screen.get_rect())

class Boss:
    def __init__(self, level):
        self.rect = pygame.Rect(WIDTH//2 - 80, HEIGHT//2 - 80, 160, 160)
        self.speed = 2 + level * 0.05
        self.timer = 0

    def update(self, player):
        dx = player.centerx - self.rect.centerx
        dy = player.centery - self.rect.centery
        d = math.hypot(dx, dy)
        if d:
            dx, dy = dx/d, dy/d
        self.rect.x += dx * self.speed
        self.rect.y += dy * self.speed

# =========================================================
# ======================= GAME STATE ======================
# =========================================================

users = load_users()
current_user = None
state = "auth"  # auth, level_select, leaderboard, playing, game_over
mode = "signin"

email = username = password = ""
error = ""

player = pygame.Rect(WIDTH//2, HEIGHT//2, PLAYER_SIZE, PLAYER_SIZE)
star = pygame.Rect(200, 200, STAR_SIZE, STAR_SIZE)

enemies = []
boss = None
boss_dialogue = ""
boss_intro_time = 0

level = 1
frames = 0
last_pos = pygame.Vector2(player.center)

cheat_detected = False

# =========================================================
# ======================= MAIN LOOP =======================
# =========================================================

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit(); sys.exit()

        if event.type == pygame.KEYDOWN:

            # ---------------- AUTH ----------------
            if state == "auth":
                if event.key == pygame.K_TAB:
                    mode = "signup" if mode == "signin" else "signin"
                    email = username = password = ""
                    error = ""

                elif event.key == pygame.K_RETURN:
                    if not valid_input(email) or not valid_input(password):
                        error = "Invalid input"
                        continue

                    users.setdefault("_meta", {})
                    attempts = users["_meta"].get(email, {"tries":0,"lock":0})

                    if attempts["lock"] > now():
                        error = "Too many attempts"
                        continue

                    if mode == "signup":
                        if len(password) < MIN_PASSWORD_LEN:
                            error = "Password too short"
                        elif email in users:
                            error = "Account exists"
                        else:
                            salt = secrets.token_hex(16)
                            users[email] = {
                                "username": username or email.split("@")[0],
                                "salt": salt,
                                "password": hash_password(password, salt),
                                "max_level": 1,
                                "best_run": 0
                            }
                            save_users(users)
                            current_user = email
                            state = "level_select"

                    else:
                        if email not in users:
                            error = "Invalid login"
                        else:
                            u = users[email]
                            if hash_password(password, u["salt"]) == u["password"]:
                                current_user = email
                                users["_meta"][email] = {"tries":0,"lock":0}
                                state = "level_select"
                            else:
                                attempts["tries"] += 1
                                if attempts["tries"] >= MAX_LOGIN_ATTEMPTS:
                                    attempts["lock"] = now() + LOCKOUT_TIME
                                users["_meta"][email] = attempts
                                error = "Invalid login"

                    email = username = password = ""

                elif event.key == pygame.K_BACKSPACE:
                    if password: password = password[:-1]
                    elif username: username = username[:-1]
                    elif email: email = email[:-1]
                else:
                    if not email:
                        email += event.unicode
                    elif mode == "signup" and not username:
                        username += event.unicode
                    else:
                        password += event.unicode

            # ---------------- LEVEL SELECT ----------------
            elif state == "level_select":
                if event.key == pygame.K_l:
                    state = "leaderboard"
                elif event.key == pygame.K_RETURN:
                    level = users[current_user]["max_level"] * 5
                    enemies.clear()
                    boss = None
                    cheat_detected = False
                    frames = 0
                    state = "playing"

            # ---------------- LEADERBOARD ----------------
            elif state == "leaderboard":
                state = "level_select"

            # ---------------- GAME OVER ----------------
            elif state == "game_over":
                if not cheat_detected:
                    users[current_user]["best_run"] = max(
                        users[current_user]["best_run"], level
                    )
                    save_users(users)
                state = "level_select"

    # ================= DRAW =================
    screen.fill(BG)

    if state == "auth":
        draw("Drift in the Dark", WIDTH//2, 60)
        draw(mode.upper(), WIDTH//2, 110)
        draw(f"Email: {email}", WIDTH//2, 170)
        if mode == "signup":
            draw(f"Username: {username}", WIDTH//2, 200)
        draw(f"Password: {'*'*len(password)}", WIDTH//2, 230)
        draw("Enter | Tab to switch", WIDTH//2, 320)
        if error: draw(error, WIDTH//2, 360)

    elif state == "level_select":
        u = users[current_user]
        draw(f"Welcome, {u['username']}", WIDTH//2, 80)
        draw(f"Checkpoint: {u['max_level']*5}", WIDTH//2, 130)
        draw("Enter to play", WIDTH//2, 200)
        draw("L for Leaderboard", WIDTH//2, 240)

    elif state == "leaderboard":
        draw("Leaderboard", WIDTH//2, 60)
        board = sorted(
            [(v["username"], v["best_run"]) for k,v in users.items() if k != "_meta"],
            key=lambda x: x[1], reverse=True
        )
        for i,(n,s) in enumerate(board[:8]):
            draw(f"{i+1}. {n} â€” Level {s}", WIDTH//2, 120+i*30)
        draw("Press any key", WIDTH//2, 430)

    elif state == "playing":
        keys = pygame.key.get_pressed()
        if keys[pygame.K_LEFT]: player.x -= PLAYER_SPEED
        if keys[pygame.K_RIGHT]: player.x += PLAYER_SPEED
        if keys[pygame.K_UP]: player.y -= PLAYER_SPEED
        if keys[pygame.K_DOWN]: player.y += PLAYER_SPEED
        player.clamp_ip(screen.get_rect())

        delta = pygame.Vector2(player.center) - last_pos
        last_pos = pygame.Vector2(player.center)

        if delta.length() > MAX_SPEED_TOLERANCE:
            cheat_detected = True

        frames += 1
        if frames % 600 == 0:
            level += 1
            if level % 10 == 0:
                boss = Boss(level)
                boss_dialogue = generate_boss_dialogue()
                boss_intro_time = pygame.time.get_ticks()
                enemies.clear()
            else:
                enemies.append(Enemy(level))
            if level % 5 == 0:
                users[current_user]["max_level"] = max(
                    users[current_user]["max_level"], level // 5
                )

        for e in enemies:
            e.update(player, delta)
            if e.rect.colliderect(player):
                state = "game_over"

        if boss:
            boss.update(player)
            if boss.rect.colliderect(player):
                state = "game_over"
            if pygame.time.get_ticks() - boss_intro_time > 15000:
                boss = None
                level += 1

        pygame.draw.rect(screen, PLAYER_COLOR, player)
        pygame.draw.rect(screen, STAR_COLOR, star)
        for e in enemies:
            pygame.draw.rect(screen, ENEMY_COLOR, e.rect)
        if boss:
            pygame.draw.rect(screen, BOSS_COLOR, boss.rect)
            if pygame.time.get_ticks() - boss_intro_time < 3000:
                draw(boss_dialogue, WIDTH//2, HEIGHT//2 - 140)

        draw(f"Level {level}", 10, 10, False)

    elif state == "game_over":
        draw("The dark remembers only truth", WIDTH//2, HEIGHT//2 - 20)
        draw("Press any key", WIDTH//2, HEIGHT//2 + 40)

    pygame.display.flip()
    clock.tick(60)
